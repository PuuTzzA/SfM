#pragma once
#include "SfM.hpp"
#include "./solve/solve.hpp"
#include "./match/match.hpp"
#include <functional>
#include <opencv2/opencv.hpp>

namespace SfM
{
    /**
     * @brief Options to control the behaviour of the scene
     * @param MATCHING_OPTIONS Options for the keypoint matching between frames
     * @param RANSAC_OPTIONS Options for RANSAC used in the eight point algorithm
     * @param useRANSAC Bool to turn off RANSAC
     * @param verbose Bool to turn off debug information
     */
    struct SCENE_OPTIONS
    {
        match::MATCHING_OPTIONS MATCHING_OPTIONS;
        solve::RANSAC_OPTIONS RANSAC_OPTIONS;
        bool useRANSAC = true;
        bool verbose = true;
    };

    /**
     * @brief Represents a scene with a vector of extrinsics and 3d points.
     * New frames can be added to the scene with the addFrame method, which calculates
     * the new pose and 3d points with the eight point algorithm.
     */
    class Scene
    {
    public:
        Scene() = default;
        Scene(const Mat3 K, const Mat4 startTransform, SCENE_OPTIONS sceneOptions);

        void setK(const Mat3 K);
        void setStartTransform(const Mat4 startTransform);
        void setMatchingOptions(match::MATCHING_OPTIONS matchingOptions);
        void setUseRANSAC(bool useRANSAC);
        void setRANSACOptions(solve::RANSAC_OPTIONS RANSAC_options);
        std::vector<Mat4> getExtrinsics();
        std::vector<Vec3> get3dPoints();

        /**
         * @brief Add a new frame at the end of the scene.
         * @param image Image
         * @param keypoints Generated by SIFT or SURF or something
         */
        void pushBackImageWithKeypoints(cv::Mat &&image, std::vector<Keypoint> &&keypoints);

        /**
         * @brief Initializes all the vectors needed to match two frames with the eight point algorihtm.
         */
        void initializeEgithPointVariables();

        /**
         * @brief Solves for the rotation and translations between the last two frames with the
         * eight point algorithm and updates accumulated pose, ...
         */
        void solveForLastAddedFrame();

        /**
         * @brief Add a new frame to the scene where the observations have already been performed. 
         * Meaning the trackId and everything is already mached.
         */
        void addFrameWithoutMatching(Frame &&frame, const int newNumTotTracks);

    private:
        static REAL getMedian(std::vector<REAL> &v);
        Vec2 normalizePoints(Vec2 pixel);

        Mat3 m_K = Mat3::Identity();
        Mat3 m_K_inv = Mat3::Identity();
        std::vector<cv::Mat> m_images;
        std::vector<std::vector<Keypoint>> m_keypoints;
        std::vector<Frame> m_frames;
        std::vector<Mat4> m_extrinsics;
        std::vector<Vec3> m_points3d; // Stores the 3d approximation in a vector with the approximation of a point with trackId i being on position i
        SCENE_OPTIONS m_sceneOptions = {};

        // Other helper member variables
        int m_currentNumTracks = 0;

        // Values that are needed to match the old frame to the new one
        std::vector<Vec2> m_shared12points1;
        std::vector<Vec2> m_shared12points2;

        std::vector<Vec2> m_shared23points2;
        std::vector<Vec2> m_shared23points3;

        std::vector<int> m_trackIndices12;
        std::vector<int> m_trackIndices23;

        REAL m_accumulatedScale = static_cast<REAL>(1.);
        Mat4 m_accumulatedPose = Mat4::Identity();
        EightPointResult m_frame12 = {};
        EightPointResult m_frame23 = {};
    };
} // Namespace SfM