#pragma once
#include "SfM.hpp"
#include "./solve/solve.hpp"
#include "./match/match.hpp"
#include <functional>
#include <opencv2/opencv.hpp>

namespace SfM
{
    /**
     * @brief Options to control the behaviour of the scene
     * @param matchingOptions Options for the keypoint matching between frames
     * @param ransacOptions Options for RANSAC used in the eight point algorithm
     * @param bundleAdjustmentOptions Options for the bundle adjustment step
     * @param useEightPoint Bool to turn of matching with the eight point algorihtm (and therefore also finding outliers with RANSAC)
     * @param splitTracks Bool to turn of automatic creation of new tracks if an outlier was detected
     * @param useRANSAC Bool to turn off RANSAC
     * @param verbose Bool to turn off debug information
     * @param maxTranslationPerFrame Maximal distance the camera can travel between frames
     */
    struct SCENE_OPTIONS
    {
        match::MATCHING_OPTIONS matchingOptions;
        solve::RANSAC_OPTIONS ransacOptions;
        solve::BUNDLE_ADJUSTMENT_OPTIONS bundleAdjustmentOptions;
        bool useEightPoint = true;
        bool splitTracks = false;
        bool useRANSAC = true;
        bool verbose = true;
        REAL maxTranslationPerFrame = 15;
    };

    /**
     * @brief Represents a scene with a vector of extrinsics and 3d points.
     * New frames can be added to the scene with the addFrame method, which calculates
     * the new pose and 3d points with the eight point algorithm.
     */
    class Scene
    {
    public:
        Scene() = default;
        Scene(const Mat3 K, const Mat4 startTransform, SCENE_OPTIONS sceneOptions);

        void setK(const Mat3 K);
        void setStartTransform(const Mat4 startTransform);
        void setSceneOptions(SCENE_OPTIONS sceneOptions);
        void setMatchingOptions(match::MATCHING_OPTIONS matchingOptions);
        void setUseRANSAC(bool useRANSAC);
        void setRANSACOptions(solve::RANSAC_OPTIONS ransacOptions);
        void setBundleAdjustmentOptions(solve::BUNDLE_ADJUSTMENT_OPTIONS bundleAdjustmentOptions);
        Mat3 getK();
        std::vector<cv::Mat> &getImages();
        std::vector<Mat4> &getExtrinsics();
        std::vector<Vec3> &get3dPoints();
        std::vector<Vec3rgb> &getColors();

        /**
         * @brief Returns the approximated 3d points, without points that are only seen from one frame (i.e. that have been marked as outliers)
         */
        std::vector<Vec3> &get3dPointsFilterd();

        /**
         * @brief Add a new frame at the end of the scene.
         * @param image Image
         * @param keypoints Generated by SIFT or SURF or something
         */
        void pushBackImageWithKeypoints(cv::Mat &&image, std::vector<Keypoint> &&keypoints);

        /**
         * @brief Perform bundle adjustment with the keypoints added until now.
         */
        void optimizeExtrinsicsAnd3dPoints();

        /**
         * @brief Add a new frame to the scene where the observations have already been performed.
         * Meaning the trackId and everything is already mached.
         */
        void addFrameWithoutMatching(Frame &&frame, const int newNumTotTracks);

    private:
        static REAL getMedian(std::vector<REAL> &v);
        Vec2 normalizePoints(Vec2 pixel);
        Vec2 denormalizePoints(Vec2 normalizedPoint);

        /**
         * @brief Initializes all the vectors needed to match two frames with the eight point algorihtm.
         */
        void initializeEgithPointVariables();

        /**
         * @brief Solves for the rotation and translations between the last two frames with the
         * eight point algorithm and updates accumulated pose, ...
         */
        void solveForLastAddedFrame();

        // Member variables
        Mat3 m_K = Mat3::Identity();
        Mat3 m_K_inv = Mat3::Identity();
        std::vector<cv::Mat> m_images;
        std::vector<std::vector<Keypoint>> m_keypoints;
        std::vector<Frame> m_frames;
        std::vector<Mat4> m_extrinsics;
        std::vector<Vec3> m_points3d;  // Stores the 3d approximation in a vector with the approximation of a point with trackId i being on position i
        std::vector<Vec3rgb> m_colors; // Stores the colors of the tracks in
        std::vector<Vec3> m_points3dFilterd;
        SCENE_OPTIONS m_sceneOptions = {};

        // Other helper member variables
        int m_currentNumTracks = 0;
        std::vector<int> m_point3dCounts; // Stores how often a 3d point was triangulated

        // Values that are needed to match the old frame to the new one
        std::vector<Vec2> m_shared12points1;
        std::vector<Vec2> m_shared12points2;

        std::vector<Vec2> m_shared23points2;
        std::vector<Vec2> m_shared23points3;

        std::vector<int> m_trackIndices12;
        std::vector<int> m_trackIndices23;

        REAL m_accumulatedScale = static_cast<REAL>(1.);
        Mat4 m_accumulatedPose = Mat4::Identity();
        EightPointResult m_frame12 = {};
        EightPointResult m_frame23 = {};
    };
} // Namespace SfM