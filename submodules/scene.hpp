#pragma once
#include "SfM.hpp"
#include "./solve/solve.hpp"
#include <functional>
#include <opencv2/opencv.hpp>

namespace SfM
{
    /**
     * @brief Represents a scene with a vector of extrinsics and 3d points.
     * New frames can be added to the scene with the addFrame method, which calculates
     * the new pose and 3d points with the eight point algorithm.
     */
    class Scene
    {
    public:
        Scene() = default;
        Scene(const Mat3 K, const Mat4 startTransform, bool useRANSAC, solve::RANSAC_OPTIONS RANSAC_options);

        void setK(const Mat3 K);
        void setStartTransform(const Mat4 startTransform);
        void setUseRANSAC(bool useRANSAC);
        void setRANSACOptions(solve::RANSAC_OPTIONS RANSAC_options);
        std::vector<Mat4> getExtrinsics();
        std::vector<Vec3> get3dPoints();

        /**
         * @brief Initializes the scene from the first frame
         */
        void initializeFromFirstFrame(Frame &&frame, const int numTotTracks);

        /**
         * @brief Add a new frame at the end of the scene. 
         * @param image Image
         * @param keypoints Generated by SIFT or SURF or something
         */
        void pushBackImageWithKeypoints(cv::Mat &&image, std::vector<Keypoint> &&keypoints);

        /**
         * @brief Add a new frame to the scene and tracks it forward
         */
        void addFrame(Frame &&frame, const int newNumTotTracks);

    private:
        Vec2 normalizePoints(Vec2 pixel);

        Mat3 m_K = Mat3::Identity();
        Mat3 m_K_inv = Mat3::Identity();
        std::vector<cv::Mat> m_images;
        std::vector<std::vector<Keypoint>> m_keypoints;
        std::vector<Frame> m_frames;
        std::vector<Mat4> m_extrinsics;
        std::vector<Vec3> m_points3d; // Stores the 3d approximation in a vector with the approximation of a point with trackId i being on position i
        bool m_useRANSAC = false;
        solve::RANSAC_OPTIONS m_RANSAC_options = {};

        // Values that are needed to match the old frame to the new one
        std::vector<Vec2> m_shared12points1;
        std::vector<Vec2> m_shared12points2;

        std::vector<Vec2> m_shared23points2;
        std::vector<Vec2> m_shared23points3;

        std::vector<int> m_trackIndices12;
        std::vector<int> m_trackIndices23;

        REAL m_accumulatedScale = static_cast<REAL>(1.);
        Mat4 m_accumulatedPose = Mat4::Identity();
        EightPointResult m_frame12 = {};
        EightPointResult m_frame23 = {};
    };
} // Namespace SfM