import bpy
import os
import json
import mathutils

# ================= CONFIGURATION =================
RELATIVE_PATH = "../../Data/S21/tisch_small.json"
# =================================================

def get_absolute_path(rel_path):
    """Safely resolves path relative to the current blend file."""
    if not bpy.data.filepath:
        return os.path.abspath(rel_path)
    
    if not rel_path.startswith("//"):
        rel_path = "//" + rel_path
        
    return bpy.path.abspath(rel_path)

def read_json_file(filepath):
    """
    Reads the JSON file generated by the C++ exporter.
    Returns a dictionary with parsed data or None if failed.
    """
    if not os.path.exists(filepath):
        print(f"Error: File not found at {filepath}")
        return None
    
    try:
        with open(filepath, 'r') as f:
            data = json.load(f)
            return data
    except json.JSONDecodeError as e:
        print(f"Error parsing JSON: {e}")
        return None

def setup_scene_dimensions(width, height):
    """Sets the render resolution to match the camera calibration."""
    render = bpy.context.scene.render
    render.resolution_x = width
    render.resolution_y = height
    render.pixel_aspect_x = 1.0
    render.pixel_aspect_y = 1.0

def apply_intrinsics_to_camera(cam_data, K_list, width, height):
    """
    Computes Focal Length and Shift based on Intrinsics Matrix K.
    K is a flat list of 9 elements (Row-Major 3x3).
    """
    # K structure: [fx, 0, cx,  0, fy, cy,  0, 0, 1]
    fx = K_list[0]
    cx = K_list[2]
    fy = K_list[4]
    cy = K_list[5]

    # 1. Set Sensor Fit
    # Blender defaults to 36mm sensor width. We stick to that to calculate focal length.
    sensor_width_mm = 36.0
    cam_data.sensor_fit = 'HORIZONTAL'
    cam_data.sensor_width = sensor_width_mm

    # 2. Calculate Focal Length in mm
    # Formula: F_mm = f_pixel * (Sensor_width_mm / Image_width_pixel)
    focal_length_mm = fx * (sensor_width_mm / width)
    cam_data.lens = focal_length_mm

    # 3. Calculate Shift (Principal Point Offset)
    # Blender Shift is normalized (0.0 to 1.0 relative to largest dimension)
    # OpenCV Origin: Top-Left. Blender Center: (0,0).
    shift_x = -(cx - (width / 2.0)) / width
    shift_y = (cy - (height / 2.0)) / width # Dividing by width because sensor fit is HORIZONTAL

    cam_data.shift_x = shift_x
    cam_data.shift_y = shift_y

    # 4. Handle Non-Square Pixels (Pixel Aspect Ratio)
    # If fy != fx, pixels are not perfectly square.
    if fx != 0:
        ratio = fy / fx
        bpy.context.scene.render.pixel_aspect_y = ratio
        print(f"Focal Length: {focal_length_mm:.2f}mm, Shift: ({shift_x:.3f}, {shift_y:.3f}), Aspect: {ratio:.3f}")

def setup_background_images(cam_obj, json_file_path, relative_img_path):
    """
    Resolves the image path, looks for the first image in that folder,
    and sets up the camera background sequence.
    """
    if not relative_img_path or not cam_obj:
        return

    # 1. Resolve Path: Combine json file directory with the relative image path
    base_dir = os.path.dirname(json_file_path)
    abs_img_dir = os.path.normpath(os.path.join(base_dir, relative_img_path))

    if not os.path.exists(abs_img_dir):
        print(f"Warning: Image directory not found at: {abs_img_dir}")
        return

    # 2. Find the first valid image file in the directory
    valid_exts = {'.png', '.jpg', '.jpeg', '.tga', '.exr', '.tif', '.tiff'}
    files = sorted([f for f in os.listdir(abs_img_dir) if os.path.splitext(f)[1].lower() in valid_exts])

    if not files:
        print(f"Warning: No image files found in {abs_img_dir}")
        return

    first_image_path = os.path.join(abs_img_dir, files[0])
    print(f"Loading image sequence starting from: {first_image_path}")

    # 3. Load the Image into Blender
    try:
        img_block = bpy.data.images.load(first_image_path)
        img_block.source = 'SEQUENCE'
    except RuntimeError as e:
        print(f"Error loading image: {e}")
        return

    # 4. Attach to Camera
    cam = cam_obj.data
    cam.show_background_images = True
    
    # Remove existing backgrounds if any
    cam.background_images.clear()
    
    bg = cam.background_images.new()
    bg.image = img_block
    bg.frame_method = 'FIT' 
    bg.alpha = 0.8  

    num_frames = len(files)
    if hasattr(bg, "image_user"):
        bg.image_user.frame_duration = num_frames
        bg.image_user.frame_start = 1
        bg.image_user.frame_offset = 0 
        bg.image_user.use_auto_refresh = True
        print(f"Set background sequence length to {num_frames} frames.")

def create_point_cloud_object(name, coords, collection):
    if not coords: return None
    # JSON arrays might be lists of lists, no conversion needed for from_pydata usually
    mesh = bpy.data.meshes.new(name=f"{name}_TempMesh")
    mesh.from_pydata(coords, [], [])
    temp_obj = bpy.data.objects.new(name, mesh)
    collection.objects.link(temp_obj)
    bpy.context.view_layer.objects.active = temp_obj
    temp_obj.select_set(True)
    try:
        bpy.ops.object.convert(target='POINTCLOUD')
        pc_obj = bpy.context.active_object
        bpy.data.meshes.remove(mesh)
        return pc_obj
    except RuntimeError:
        print("WARNING: Could not convert to native Point Cloud. Keeping as Mesh.")
        return temp_obj

def list_to_matrix(flat_list):
    """Converts a flat list of 16 floats into a 4x4 Mathutils Matrix."""
    if len(flat_list) != 16:
        return mathutils.Matrix() # Identity fallback
    
    # Create rows
    rows = [
        flat_list[0:4],
        flat_list[4:8],
        flat_list[8:12],
        flat_list[12:16]
    ]
    return mathutils.Matrix(rows)

def main():
    # 1. Resolve Path
    full_path = get_absolute_path(RELATIVE_PATH)
    print(f"Importing JSON from: {full_path}")

    # 2. Read Data
    data = read_json_file(full_path)
    if not data:
        return

    # Extract Data Fields
    width = data.get('width', 1920)
    height = data.get('height', 1080)
    K = data.get('K', [])
    extrinsics_flat = data.get('extrinsics', [])
    points_coords = data.get('points', [])
    img_rel_path = data.get('pathToImages', None)

    # 3. Setup Collection
    filename = os.path.basename(full_path)
    col_name = f"SfM_{os.path.splitext(filename)[0]}"
    
    if col_name in bpy.data.collections:
        existing_col = bpy.data.collections[col_name]
        for obj in existing_col.objects:
            bpy.data.objects.remove(obj, do_unlink=True)
        bpy.data.collections.remove(existing_col)
        
    new_col = bpy.data.collections.new(col_name)
    bpy.context.scene.collection.children.link(new_col)

    cam_obj = None

    # 4. Setup Scene Resolution
    setup_scene_dimensions(width, height)

    # 5. Create Camera
    if extrinsics_flat:
        cam_data = bpy.data.cameras.new(name="ImportedCam_Data")
        cam_obj = bpy.data.objects.new(name="ImportedCamera", object_data=cam_data)
        new_col.objects.link(cam_obj)
        
        # --- NEW: APPLY INTRINSICS ---
        if K and len(K) == 9:
            apply_intrinsics_to_camera(cam_data, K, width, height)
        else:
            print("Warning: No valid Intrinsics (K) found in JSON.")
        # -----------------------------

        # Set Framerate/Range
        bpy.context.scene.frame_start = 1
        bpy.context.scene.frame_end = len(extrinsics_flat)
        
        print(f"Creating Camera Animation ({len(extrinsics_flat)} frames)...")
        
        for i, flat_mat in enumerate(extrinsics_flat):
            frame_num = i + 1
            # Convert flat list to Matrix
            mat = list_to_matrix(flat_mat)
            
            cam_obj.matrix_world = mat
            cam_obj.keyframe_insert(data_path="location", frame=frame_num)
            cam_obj.keyframe_insert(data_path="rotation_euler", frame=frame_num)

        bpy.ops.object.select_all(action='DESELECT')
        cam_obj.select_set(True)
        bpy.context.view_layer.objects.active = cam_obj
        
        print("Calculating Motion Path...")
        # Actually calculate the path lines
        bpy.ops.object.paths_calculate(range='MANUAL')

        # Optional: visual path
        # bpy.ops.object.paths_calculate(range='MANUAL')

        # --- SETUP BACKGROUND IMAGES ---
        if img_rel_path:
            setup_background_images(cam_obj, full_path, img_rel_path)
        # -------------------------------

    # 6. Create Point Cloud
    if points_coords:
        print(f"Creating Point Cloud ({len(points_coords)} points)...")
        pc_obj = create_point_cloud_object("PointCloud", points_coords, new_col)
        
        if pc_obj:
            # Add Geometry Nodes modifier to make points renderable (Cycles)
            mod = pc_obj.modifiers.new(name="GeoNodes", type='NODES')
            node_group_name = "points" # Assumes you have a node group named "points" to instance spheres/discs
            if node_group_name in bpy.data.node_groups:
                mod.node_group = bpy.data.node_groups[node_group_name]

    bpy.ops.object.select_all(action='DESELECT')
    print("Import Finished Successfully.")

if __name__ == "__main__":
    main()